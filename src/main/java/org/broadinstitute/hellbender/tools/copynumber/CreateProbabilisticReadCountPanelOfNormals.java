package org.broadinstitute.hellbender.tools.copynumber;

import htsjdk.samtools.SAMSequenceDictionary;
import org.apache.commons.math3.linear.Array2DRowRealMatrix;
import org.apache.commons.math3.linear.RealMatrix;
import org.apache.logging.log4j.Logger;
import org.apache.spark.api.java.JavaSparkContext;
import org.broadinstitute.barclay.argparser.Argument;
import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;
import org.broadinstitute.barclay.help.DocumentedFeature;
import org.broadinstitute.hdf5.HDF5Library;
import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;
import org.broadinstitute.hellbender.cmdline.programgroups.CopyNumberProgramGroup;
import org.broadinstitute.hellbender.engine.GATKTool;
import org.broadinstitute.hellbender.engine.spark.SparkCommandLineProgram;
import org.broadinstitute.hellbender.exceptions.UserException;
import org.broadinstitute.hellbender.tools.copynumber.annotation.GCBiasCorrector;
import org.broadinstitute.hellbender.tools.copynumber.coverage.denoising.svd.HDF5SVDReadCountPanelOfNormals;
import org.broadinstitute.hellbender.tools.copynumber.coverage.readcount.SimpleCountCollection;
import org.broadinstitute.hellbender.tools.copynumber.formats.CopyNumberArgumentValidationUtils;
import org.broadinstitute.hellbender.tools.copynumber.formats.CopyNumberStandardArgument;
import org.broadinstitute.hellbender.utils.SimpleInterval;
import org.broadinstitute.hellbender.utils.Utils;
import org.broadinstitute.hellbender.utils.io.IOUtils;

import java.io.File;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.ListIterator;
import java.util.stream.Collectors;

/**
 * Tool to create a probabilistic panel of normals (PoN) given read counts for control samples.  These should be either
 * HDF5 or TSV output files generated by {@link CollectFragmentCounts}.  Calls for germline events in the
 * control samples are also output to VCF.
 *
 * TODO
 *
 * <h3>Examples</h3>
 *
 * <pre>
 * gatk-launch --javaOptions "-Xmx4g" CreateProbabilisticReadCountPanelOfNormals \
 *   --input normal_1.readCounts.hdf5 \
 *   --input normal_2.readCounts.hdf5 \
 *   ... \
 *   --output panel_of_normals_dir
 * </pre>
 *
 * @author Samuel Lee &lt;slee@broadinstitute.org&gt;
 */
@CommandLineProgramProperties(
        summary = "Create a panel of normals for read-count denoising and call germline copy-number events, " +
                "given the read counts for samples in the panel.",
        oneLineSummary = "Create a panel of normals for read-count denoising and call germline copy-number events.",
        programGroup = CopyNumberProgramGroup.class
)
@DocumentedFeature
public final class CreateProbabilisticReadCountPanelOfNormals extends GATKTool {
    private static final String DENOISING_MODEL_SUBDIRECTORY = "model/";
    private static final String CALLS_SUBDIRECTORY = "calls/";

    @Argument(
            doc = "Input read-count files containing integer read counts in genomic intervals for all samples in the panel of normals." +
                    "Intervals provided via -L must be contained in all samples.",
            fullName = StandardArgumentDefinitions.INPUT_LONG_NAME,
            shortName = StandardArgumentDefinitions.INPUT_SHORT_NAME,
            minElements = 1
    )
    private List<File> inputReadCountFiles = new ArrayList<>();

    @Argument(
            doc = "Input annotated-interval file containing annotations for GC content in genomic intervals (output of AnnotateIntervals).  " +
                    "Intervals must be identical to those provided via -L.",
            fullName = CopyNumberStandardArgument.ANNOTATED_INTERVALS_FILE_LONG_NAME,
            shortName = CopyNumberStandardArgument.ANNOTATED_INTERVALS_FILE_SHORT_NAME,
            optional = true
    )
    private File annotatedIntervalsFile = null;

    @Argument(
            doc = "Output directory.  Denoising model will be output to the subdirectory " + DENOISING_MODEL_SUBDIRECTORY +
                    " and calls will be output to the subdirectory " + CALLS_SUBDIRECTORY + ".",
            fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME,
            shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME
    )
    private File outputDir;

    @Override
    public void onTraversalStart() {
        validateArguments();

        //get intervals
        final SAMSequenceDictionary sequenceDictionary = getBestAvailableSequenceDictionary();
        final List<SimpleInterval> intervals = intervalArgumentCollection.getIntervals(sequenceDictionary);

        //get sample filenames
        final List<String> sampleFilenames = inputReadCountFiles.stream().map(File::getAbsolutePath).collect(Collectors.toList());

        //get GC content (null if not provided)
        final double[] intervalGCContent = GCBiasCorrector.validateIntervalGCContent(intervals, annotatedIntervalsFile);

        //validate input read-count files (i.e., check intervals and that only integer counts are contained)
        //and aggregate as a RealMatrix with dimensions numIntervals x numSamples
        final RealMatrix readCountMatrix = constructReadCountMatrix(logger, inputReadCountFiles, intervals);

        //TODO

        logger.info("Panel of normals successfully created.");
    }

    private void validateArguments() {
        CopyNumberArgumentValidationUtils.validateIntervalArgumentCollection(intervalArgumentCollection);

        Utils.validateArg(inputReadCountFiles.size() == new HashSet<>(inputReadCountFiles).size(),
                "List of input read-count files cannot contain duplicates.");
        inputReadCountFiles.forEach(IOUtils::canReadFile);
    }

    private RealMatrix constructReadCountMatrix(final Logger logger,
                                                final List<File> inputReadCountFiles,
                                                final List<SimpleInterval> intervals) {
        logger.info("Validating and aggregating input read-count files...");
        final int numSamples = inputReadCountFiles.size();
        final int numIntervals = intervals.size();
        final RealMatrix readCountMatrix = new Array2DRowRealMatrix(numSamples, numIntervals);
        final ListIterator<File> inputReadCountFilesIterator = inputReadCountFiles.listIterator();
        while (inputReadCountFilesIterator.hasNext()) {
            final int sampleIndex = inputReadCountFilesIterator.nextIndex();
            final File inputReadCountFile = inputReadCountFilesIterator.next();
            logger.info(String.format("Aggregating read-count file %s (%d / %d)", inputReadCountFile, sampleIndex + 1, numSamples));
            final SimpleCountCollection readCounts = SimpleCountCollection.read(inputReadCountFile);
            Utils.validateArg(readCounts.getIntervals().equals(intervals),
                    String.format("Intervals for read-count file %s do not match those in other read-count files.", inputReadCountFile));
            readCountMatrix.setRow(sampleIndex, readCounts.getCounts());
        }
        return readCountMatrix;
    }

    @Override
    public void traverse() {}  // no traversal for this tool
}
